<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Upper Body Workout Coach (A/B/C) — Offline + Timers</title>
  <meta name="theme-color" content="#0b1020" />
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --panel2:#0f1630;
      --text:#eaf0ff;
      --muted:#a9b6e6;
      --accent:#6ee7ff;
      --accent2:#8b5cf6;
      --danger:#ff5c7a;
      --ok:#45f7a2;
      --warn:#ffd166;
      --border:rgba(255,255,255,.12);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:18px;
      --radius2:14px;
      --tap:56px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      background: radial-gradient(1200px 900px at 30% -10%, rgba(110,231,255,.22), transparent 60%),
                  radial-gradient(900px 700px at 100% 10%, rgba(139,92,246,.22), transparent 55%),
                  linear-gradient(180deg, #070a16, var(--bg));
      color:var(--text);
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      overflow-x:hidden;
    }

    .app{
      max-width: 980px;
      margin: 0 auto;
      padding: 14px 14px 92px;
    }

    header{
      position: sticky;
      top:0;
      z-index: 50;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(11,16,32,.92), rgba(11,16,32,.55));
      border-bottom: 1px solid var(--border);
      padding: 12px 0 10px;
      margin: 0 -14px 14px;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 0 14px;
    }

    .brand{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 0;
    }
    .brand h1{
      font-size: 16px;
      letter-spacing:.2px;
      margin:0;
      font-weight: 750;
      white-space:nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .brand .sub{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      background: rgba(18,26,51,.65);
      box-shadow: var(--shadow);
      border-radius: 999px;
      user-select:none;
    }

    .pill small{color:var(--muted); font-size:12px}
    .pill strong{font-family:var(--mono); font-weight:800; font-size: 12px}

    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:14px;
    }

    @media (max-width: 900px){
      .grid{grid-template-columns: 1fr}
    }

    .card{
      border:1px solid var(--border);
      background: linear-gradient(180deg, rgba(18,26,51,.82), rgba(15,22,48,.82));
      box-shadow: var(--shadow);
      border-radius: var(--radius);
      overflow:hidden;
    }
    .card .hd{
      padding: 14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .card .hd h2{
      margin:0;
      font-size: 15px;
      font-weight: 760;
      letter-spacing:.2px;
    }
    .card .hd .meta{
      color:var(--muted);
      font-size:12px;
    }
    .card .bd{padding: 12px 14px 14px}

    .row{display:flex; gap:10px; flex-wrap:wrap}
    .row>*{flex:1 1 auto}

    .btn{
      height: var(--tap);
      padding: 0 14px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font-weight: 750;
      letter-spacing: .2px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .05s ease, background .15s ease;
    }
    .btn:active{transform: scale(.99)}
    .btn.primary{
      background: linear-gradient(90deg, rgba(110,231,255,.2), rgba(139,92,246,.22));
      border-color: rgba(110,231,255,.3);
    }
    .btn.danger{
      background: rgba(255,92,122,.13);
      border-color: rgba(255,92,122,.35);
    }
    .btn.ok{
      background: rgba(69,247,162,.12);
      border-color: rgba(69,247,162,.35);
    }
    .btn.ghost{
      background: transparent;
      border-color: rgba(255,255,255,.14);
    }
    .btn.small{
      height: 44px;
      border-radius: 12px;
      font-size: 13px;
      padding: 0 12px;
    }

    .seg{
      display:flex;
      border: 1px solid var(--border);
      border-radius: 14px;
      overflow:hidden;
      background: rgba(255,255,255,.04);
    }
    .seg button{
      flex:1;
      height: 44px;
      border:0;
      background: transparent;
      color: var(--muted);
      font-weight: 780;
      cursor:pointer;
    }
    .seg button.on{
      background: rgba(110,231,255,.13);
      color: var(--text);
    }

    .statline{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .statline .kv{
      display:flex;
      gap:8px;
      align-items:center;
      color: var(--muted);
      font-size: 12px;
    }
    .statline .kv b{color: var(--text); font-family:var(--mono); font-size: 12px}

    .bigTimer{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .time{
      font-family: var(--mono);
      font-weight: 900;
      font-size: 54px;
      letter-spacing: .8px;
      line-height: 1;
      text-align:center;
      margin: 8px 0 2px;
    }
    .phase{
      text-align:center;
      color: var(--muted);
      font-weight: 700;
      font-size: 13px;
    }

    .progress{
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
    }
    .bar{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(110,231,255,.85), rgba(139,92,246,.85));
      border-radius: 999px;
      transition: width .25s linear;
    }

    .exerciseTitle{
      margin: 8px 0 2px;
      font-size: 18px;
      font-weight: 860;
      letter-spacing:.2px;
    }
    .exerciseSub{
      color: var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }

    details{
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,.04);
    }
    details summary{
      cursor:pointer;
      font-weight: 800;
      color: var(--text);
      list-style:none;
      outline:none;
      -webkit-tap-highlight-color: transparent;
    }
    details summary::-webkit-details-marker{display:none}
    .help{
      margin-top:10px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45;
    }
    .help b{color: var(--text)}

    .list{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .item{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 14px;
      padding: 10px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .item .left{min-width:0}
    .item .name{
      font-weight: 850;
      font-size: 14px;
      margin:0 0 2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .item .desc{
      margin:0;
      color: var(--muted);
      font-size: 12px;
      line-height:1.35;
    }
    .badge{
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 900;
      padding: 8px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      color: var(--text);
      background: rgba(0,0,0,.18);
      white-space:nowrap;
    }
    .badge.ok{border-color: rgba(69,247,162,.35); background: rgba(69,247,162,.10)}
    .badge.warn{border-color: rgba(255,209,102,.35); background: rgba(255,209,102,.10)}
    .badge.info{border-color: rgba(110,231,255,.35); background: rgba(110,231,255,.10)}
    .badge.danger{border-color: rgba(255,92,122,.35); background: rgba(255,92,122,.10)}

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin: 10px 0;
    }
    label{
      font-size:12px;
      color: var(--muted);
      font-weight: 800;
      letter-spacing:.2px;
    }
    input, select, textarea{
      border:1px solid rgba(255,255,255,.12);
      border-radius: 14px;
      background: rgba(0,0,0,.22);
      color: var(--text);
      padding: 12px 12px;
      font-size: 15px;
      outline:none;
    }
    textarea{min-height: 84px; resize: vertical}
    .hint{
      color: var(--muted);
      font-size: 12px;
      line-height:1.35;
    }

    .stickyControls{
      position: fixed;
      left:0; right:0; bottom:0;
      z-index: 60;
      background: linear-gradient(180deg, rgba(11,16,32,.1), rgba(11,16,32,.92) 40%, rgba(11,16,32,.98));
      border-top:1px solid var(--border);
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      backdrop-filter: blur(10px);
    }
    .controlsWrap{
      max-width: 980px;
      margin: 0 auto;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .controlsWrap .btn{flex:1}
    .controlsWrap .btn.small{flex:0 0 auto}

    .toast{
      position: fixed;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 80;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      padding: 10px 12px;
      border-radius: 999px;
      color: var(--text);
      font-weight: 800;
      font-size: 13px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      max-width: 92vw;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .toast.on{opacity:1}
    .mono{font-family:var(--mono)}
    .muted{color:var(--muted)}
    .tiny{font-size: 12px}
    .divider{height:1px; background: rgba(255,255,255,.10); margin: 12px 0}
    .kpi{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .kpi .box{
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      background: rgba(255,255,255,.04);
      padding: 10px 12px;
    }
    .kpi .box .t{color:var(--muted); font-size:12px; font-weight:800}
    .kpi .box .v{font-family:var(--mono); font-weight:900; font-size: 14px; margin-top:4px}
    .hide{display:none !important;}
  </style>
</head>

<body>
  <div class="toast" id="toast">Saved</div>

  <header>
    <div class="topbar">
      <div class="brand">
        <h1>Upper Body Workout Coach</h1>
        <div class="sub">A / B / C sessions • timers • auto-progress • offline local storage</div>
      </div>
      <div class="pill" aria-label="workout status">
        <small>Status</small>
        <strong id="statusPill">Ready</strong>
      </div>
    </div>
  </header>

  <div class="app">
    <div class="grid">

      <!-- LEFT: Player -->
      <section class="card" aria-label="Workout player">
        <div class="hd">
          <div>
            <h2>Workout Player</h2>
            <div class="meta" id="playerMeta">Pick A/B/C, then press Start. The workout will auto-advance.</div>
          </div>
          <div class="seg" role="tablist" aria-label="Session selector">
            <button id="tabA" class="on" aria-selected="true">A</button>
            <button id="tabB" aria-selected="false">B</button>
            <button id="tabC" aria-selected="false">C</button>
          </div>
        </div>

        <div class="bd">
          <div class="statline">
            <div class="kv">Step <b id="stepCount">0/0</b></div>
            <div class="kv">Up next <b id="nextLabel">—</b></div>
            <div class="kv">Session <b id="sessionLabel">A</b></div>
          </div>

          <div class="bigTimer" style="margin-top:10px">
            <div class="time" id="timeDisplay">00:00</div>
            <div class="phase" id="phaseDisplay">Ready</div>
            <div class="progress" aria-label="timer progress">
              <div class="bar" id="progressBar"></div>
            </div>
          </div>

          <div class="divider"></div>

          <div>
            <div class="exerciseTitle" id="exerciseTitle">Select a session</div>
            <div class="exerciseSub" id="exerciseSub">This page is designed for phone use: big buttons, auto-timers, clear cues.</div>
          </div>

          <div class="divider"></div>

          <details id="detailsHow">
            <summary>How to do it (tap to expand)</summary>
            <div class="help" id="howText"></div>
          </details>

          <div class="divider"></div>

          <details id="detailsLog">
            <summary>Log (optional)</summary>
            <div class="help">
              <div class="field">
                <label for="logWeight">Weight used</label>
                <input id="logWeight" inputmode="decimal" placeholder="e.g., Bench 95 lb" />
                <div class="hint">Tip: log just the main lifts (bench, OHP, row). Stored locally.</div>
              </div>
              <div class="field">
                <label for="logNotes">Notes (pain, form cues, wins)</label>
                <textarea id="logNotes" placeholder="e.g., shoulders felt good, paused reps helped"></textarea>
              </div>
              <button class="btn ok" id="btnSaveLog">Save log for this step</button>
            </div>
          </details>

          <div class="divider"></div>

          <details open>
            <summary>Today’s run list</summary>
            <div class="list" id="runList"></div>
          </details>

        </div>
      </section>

      <!-- RIGHT: Settings + History -->
      <aside class="card" aria-label="Settings and history">
        <div class="hd">
          <div>
            <h2>Settings</h2>
            <div class="meta">Tune timers for your pace. Everything persists in localStorage.</div>
          </div>
          <button class="btn small ghost" id="btnResetAll" title="Reset local storage">Reset</button>
        </div>

        <div class="bd">
          <div class="field">
            <label for="prepSeconds">Auto “Get ready” countdown (seconds)</label>
            <input id="prepSeconds" type="number" min="3" max="45" step="1" />
            <div class="hint">This runs before every timed block so you can set up safely.</div>
          </div>

          <div class="field">
            <label for="restMain">Rest after main barbell sets (seconds)</label>
            <input id="restMain" type="number" min="30" max="300" step="5" />
            <div class="hint">Bench/OHP/Row default: 150–180 sec. Adjust to your reality.</div>
          </div>

          <div class="field">
            <label for="restAccessory">Rest after accessory sets (seconds)</label>
            <input id="restAccessory" type="number" min="20" max="180" step="5" />
            <div class="hint">DB work / raises / curls default: 60–90 sec.</div>
          </div>

          <div class="field">
            <label for="restMicro">Rest inside pull-up practice (seconds)</label>
            <input id="restMicro" type="number" min="20" max="120" step="5" />
            <div class="hint">Used for singles/holds/negatives. Keep it tidy.</div>
          </div>

          <div class="field">
            <label for="soundMode">Sound / vibration</label>
            <select id="soundMode">
              <option value="beep">Beep</option>
              <option value="vibe">Vibrate (if supported)</option>
              <option value="both">Beep + Vibrate</option>
              <option value="off">Off</option>
            </select>
            <div class="hint">Phones sometimes require an interaction before audio works (press Start once).</div>
          </div>

          <div class="kpi">
            <div class="box">
              <div class="t">Last session</div>
              <div class="v" id="kpiLast">—</div>
            </div>
            <div class="box">
              <div class="t">Sessions completed</div>
              <div class="v" id="kpiCount">0</div>
            </div>
          </div>

          <div class="divider"></div>

          <details>
            <summary>History (tap)</summary>
            <div class="help" id="historyBox"></div>
          </details>

          <div class="divider"></div>

          <details>
            <summary>Safety & pacing rules</summary>
            <div class="help">
              <p><b>Never grind pull-ups.</b> No missed reps. Focus on clean holds/negatives/singles.</p>
              <p><b>Main lifts</b> (bench/OHP/rows): stop with ~2 reps “in reserve” most of the time. Avoid maxing.</p>
              <p><b>If something hurts sharply</b> (not normal effort): stop that movement and skip to the next step.</p>
              <p><b>Cycle integration:</b> on lifting days keep the ride moderate, or lift before cycling if you want more strength.</p>
            </div>
          </details>

        </div>
      </aside>

    </div>
  </div>

  <!-- Sticky bottom controls (phone-friendly) -->
  <div class="stickyControls" role="group" aria-label="Workout controls">
    <div class="controlsWrap">
      <button class="btn danger small" id="btnBack" title="Previous step">◀</button>
      <button class="btn primary" id="btnStartPause">Start</button>
      <button class="btn small ghost" id="btnSkip" title="Skip timer / next step">Skip ▶</button>
    </div>
  </div>

<script>
(() => {
  // ---------- Local storage keys ----------
  const LS_KEY = "ub_coach_v1";
  const defaultState = {
    session: "A",
    settings: {
      prepSeconds: 8,
      restMain: 165,
      restAccessory: 75,
      restMicro: 60,
      soundMode: "beep",
    },
    player: {
      running: false,
      paused: false,
      stepIndex: 0,
      phase: "READY", // READY, PREP, WORK, REST, DONE
      remaining: 0,
      phaseTotal: 0,
      lastTick: 0
    },
    logs: {}, // stepId -> {weight, notes, ts}
    history: [] // {ts, session, durationSeconds, completedSteps}
  };

  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return structuredClone(defaultState);
      const parsed = JSON.parse(raw);
      // merge shallowly to keep forward-compat
      return {
        ...structuredClone(defaultState),
        ...parsed,
        settings: {...structuredClone(defaultState.settings), ...(parsed.settings||{})},
        player: {...structuredClone(defaultState.player), ...(parsed.player||{})},
        logs: parsed.logs || {},
        history: parsed.history || []
      };
    } catch(e){
      return structuredClone(defaultState);
    }
  }

  function saveState(){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
    toast("Saved");
    refreshKPIs();
  }

  function resetAll(){
    state = structuredClone(defaultState);
    localStorage.setItem(LS_KEY, JSON.stringify(state));
    toast("Reset complete");
    initUI();
  }

  let state = loadState();

  // ---------- Audio / vibration ----------
  let audioCtx = null;
  function beep(){
    if(state.settings.soundMode === "off") return;
    const doVibe = (state.settings.soundMode === "vibe" || state.settings.soundMode === "both");
    const doBeep = (state.settings.soundMode === "beep" || state.settings.soundMode === "both");

    if(doVibe && navigator.vibrate){
      navigator.vibrate([60, 30, 60]);
    }
    if(!doBeep) return;

    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = 880;
      g.gain.value = 0.06;
      o.connect(g);
      g.connect(audioCtx.destination);
      o.start();
      setTimeout(()=>{ o.stop(); }, 120);
    } catch(e){
      // ignore
    }
  }

  // ---------- Workout data model ----------
  // Each "step" is either:
  // - timer-driven (prep->work->rest loops) or
  // - instruction-only (no timer) but still auto-progresses using a short prep
  // For phone usability: "work" is the set period or practice period; then rest starts automatically.
  // For non-timed (e.g., "perform 4 sets"), we guide you through sets with rest between.

  function mkStepId(session, idx){ return `${session}_${idx}`; }

  function fmtSetsReps(sets, reps){
    if(!sets) return "";
    const r = Array.isArray(reps) ? `${reps[0]}–${reps[1]}` : reps;
    return `${sets} sets × ${r}`;
  }

  const INSTRUCTIONS = {
    // --- Pull-up components ---
    "Dead Hang": `
      <p><b>Setup:</b> grab the bar with hands about shoulder-width. Knees bent is fine. Start from a full hang with shoulders not jammed into your ears.</p>
      <p><b>Do it:</b> hang while keeping ribs down and a light brace. Let shoulder blades stay “set” (not shrugged). Breathe slowly.</p>
      <p><b>Stop if:</b> you feel sharp shoulder pain, numbness/tingling, or your grip is failing suddenly.</p>
      <p><b>Goal:</b> build grip + shoulder tolerance for pull-ups. Over time increase hold duration.</p>
    `,
    "Scapular Pull-ups": `
      <p><b>What it is:</b> a pull-up “start” without bending the elbows.</p>
      <p><b>Setup:</b> hang from the bar. Elbows locked straight. Knees can be bent.</p>
      <p><b>Move:</b> pull your shoulder blades down and back (like putting them in your back pockets). Your body rises a little. Then return to the relaxed hang.</p>
      <p><b>Cues:</b> “Shoulders away from ears.” “Chest tall.” Do not bend elbows.</p>
      <p><b>Common mistake:</b> turning it into tiny pull-ups by bending elbows.</p>
    `,
    "Top Hold (Chin Over Bar)": `
      <p><b>Setup:</b> use a small jump or step to get your chin over the bar. Knees bent is fine.</p>
      <p><b>Hold:</b> keep chin over the bar, chest lifted, shoulders down. Hold for the prescribed seconds.</p>
      <p><b>Goal:</b> teach your body the top position and build strength where you’re currently weakest.</p>
      <p><b>Do not:</b> crank your neck. Keep eyes forward and let the back do the work.</p>
    `,
    "Negative Pull-up": `
      <p><b>Setup:</b> jump/step to the top position (chin above bar). Start tight: shoulders down, abs lightly braced.</p>
      <p><b>Lower:</b> descend slowly for the prescribed seconds. Control the whole way. Keep elbows tracking down toward your ribs.</p>
      <p><b>Finish:</b> return to a full hang with control (don’t drop).</p>
      <p><b>Goal:</b> negatives are the fastest way to turn “barely 1” into multiple clean reps.</p>
    `,
    "Mid-point Hold (90° Elbows)": `
      <p><b>Setup:</b> jump to the top, then lower until elbows are about 90° (halfway).</p>
      <p><b>Hold:</b> keep shoulders down and chest tall, hold for the prescribed seconds.</p>
      <p><b>Why:</b> strengthens the “sticking point” range and improves control.</p>
    `,

    // --- Main lifts ---
    "Barbell Bench Press": `
      <p><b>Setup:</b> lie on the bench with eyes under the bar. Feet flat and slightly behind knees for stability. Grip a bit wider than shoulder-width.</p>
      <p><b>Unrack:</b> squeeze shoulder blades <b>back and down</b>. Lift bar out and hold above mid-chest.</p>
      <p><b>Lower:</b> bar comes down to lower chest / sternum area, elbows ~45° from your torso (not flared straight out).</p>
      <p><b>Press:</b> push the bar up and slightly back toward your face. Keep shoulder blades pinned; don’t shrug.</p>
      <p><b>Breathing:</b> big breath before lowering; hold during press; exhale at the top.</p>
      <p><b>Safety:</b> if you bench alone, use conservative loads and leave reps in reserve.</p>
    `,
    "Paused Bench Press": `
      <p>Same setup as bench press, but:</p>
      <p><b>Pause:</b> after the bar touches your chest, hold it still for <b>1–2 seconds</b> (no bouncing), then press.</p>
      <p><b>Why:</b> builds strength without needing tiny weight jumps; improves control and shoulder positioning.</p>
    `,
    "Close-Grip Bench Press": `
      <p><b>Goal:</b> triceps + stronger bench lockout.</p>
      <p><b>Grip:</b> hands about shoulder-width (closer than regular bench, but not “hands touching”).</p>
      <p><b>Elbows:</b> keep elbows tucked ~30–45° from torso. Lower to lower chest, press up smoothly.</p>
      <p><b>Tip:</b> if wrists feel weird, widen grip slightly.</p>
    `,
    "Standing Barbell Overhead Press": `
      <p><b>Setup:</b> stand tall with feet about shoulder width. Bar starts at upper chest/clavicle. Grip just outside shoulder width.</p>
      <p><b>Brace:</b> squeeze glutes, ribs down, light abdominal brace. Don’t lean back to “cheat” it.</p>
      <p><b>Press:</b> bar goes up in a near-vertical path. Move your head slightly back as it passes, then forward under the bar at the top.</p>
      <p><b>Lower:</b> return to upper chest with control.</p>
      <p><b>Common mistakes:</b> over-arching the low back, shrugging shoulders, bar drifting forward.</p>
    `,
    "Barbell Row (Pause at Top)": `
      <p><b>Setup:</b> stand with feet hip-width. Hinge at the hips until torso is around 30–45° to the floor. Keep a neutral spine.</p>
      <p><b>Row:</b> pull the bar toward your lower ribs / upper stomach. Elbows move back. <b>Pause 1 second</b> at the top.</p>
      <p><b>Lower:</b> return the bar down with control. Don’t jerk with your lower back.</p>
      <p><b>Cues:</b> “Proud chest.” “Pull elbows to hips.” “No shrugging.”</p>
    `,
    "Barbell Row (Tempo)": `
      <p>Same as barbell row, but:</p>
      <p><b>Tempo:</b> lower the bar for <b>3 seconds</b> every rep. Keep the hinge position stable.</p>
      <p><b>Why:</b> increases difficulty without needing more plates; builds back control and posture.</p>
    `,

    // --- Dumbbell / bodyweight accessories ---
    "Incline Dumbbell Press": `
      <p><b>Setup:</b> set the bench to a low incline. Start with dumbbells at upper chest. Feet planted.</p>
      <p><b>Press:</b> push up and slightly together. Don’t bang dumbbells at the top.</p>
      <p><b>Lower:</b> slow, controlled, elbows ~45° from torso.</p>
      <p><b>Tip:</b> keep shoulder blades back/down; avoid shrugging.</p>
    `,
    "Dumbbell Bench Press": `
      <p><b>Setup:</b> dumbbells start at chest level. Shoulder blades pinned back/down like barbell bench.</p>
      <p><b>Press:</b> push up; keep wrists stacked over elbows. Controlled reps.</p>
      <p><b>Why:</b> great volume builder with limited equipment.</p>
    `,
    "One-Arm Dumbbell Row": `
      <p><b>Setup:</b> one knee + hand on bench, spine long. Other hand holds DB.</p>
      <p><b>Row:</b> pull DB toward your hip. <b>Pause 1 second</b> at the top.</p>
      <p><b>Lower:</b> slow down; let the shoulder blade stretch at bottom.</p>
      <p><b>Common mistake:</b> twisting torso a lot. Keep hips mostly square.</p>
    `,
    "Push-ups": `
      <p><b>Setup:</b> hands under shoulders (or slightly wider). Body straight line from head to heels (or knees if modified).</p>
      <p><b>Lower:</b> chest toward floor/bench. Elbows about 30–45° from torso.</p>
      <p><b>Press:</b> push the floor away. Keep core braced and avoid sagging hips.</p>
      <p><b>Options:</b> hands on bench (easier) or feet on bench (harder).</p>
    `,
    "Rear Delt Fly": `
      <p><b>Setup:</b> hinge at hips, torso angled down. Dumbbells hang below shoulders.</p>
      <p><b>Move:</b> raise arms out to the sides with a slight elbow bend, like making a “T”.</p>
      <p><b>Control:</b> slow, strict reps. Stop before shrugging.</p>
      <p><b>Why:</b> balances pressing, improves posture, protects shoulders.</p>
    `,
    "Lateral Raise": `
      <p><b>Setup:</b> stand tall, slight bend in elbows, dumbbells at sides.</p>
      <p><b>Raise:</b> lift to shoulder height (or slightly below). Lead with elbows.</p>
      <p><b>Control:</b> no swinging. If needed, use lighter weights and slow down.</p>
    `,
    "Curl-bar Curl": `
      <p><b>Setup:</b> stand tall, elbows close to sides, curl bar in hands.</p>
      <p><b>Curl:</b> bring bar up by bending elbows only. Don’t lean back.</p>
      <p><b>Lower:</b> slow. Keep wrists neutral.</p>
      <p><b>Why:</b> helps pull-ups when you’re at low rep numbers.</p>
    `,
    "Hammer Curl": `
      <p><b>Setup:</b> hold dumbbells or kettlebells with thumbs up (neutral grip).</p>
      <p><b>Curl:</b> raise without rotating wrist. Keep elbow close to side.</p>
      <p><b>Benefit:</b> trains forearms and elbow flexors; great for pull-up support.</p>
    `,
    "Skull Crushers (curl bar)": `
      <p><b>Setup:</b> lie on bench. Hold curl bar above chest with elbows pointed up.</p>
      <p><b>Lower:</b> bend elbows, bringing bar toward forehead/top of head. Upper arms stay mostly still.</p>
      <p><b>Press:</b> extend elbows to return. Keep reps smooth and controlled.</p>
      <p><b>If elbows hurt:</b> switch to close-grip bench.</p>
    `,
    "Overhead Triceps Extension (KB/DB)": `
      <p><b>Setup:</b> hold one kettlebell/dumbbell overhead with both hands.</p>
      <p><b>Lower:</b> bend elbows, bring weight behind head under control.</p>
      <p><b>Raise:</b> extend elbows back to overhead. Keep ribs down.</p>
    `,

    // --- Shoulder health block ---
    "Prone Y-T-W": `
      <p><b>Setup:</b> lie face down on a bench (or hinge forward). Light weights or none.</p>
      <p><b>Y:</b> arms angled overhead like a “Y”. Lift, pause 1 sec, lower.</p>
      <p><b>T:</b> arms straight out to sides like a “T”. Lift, pause, lower.</p>
      <p><b>W:</b> elbows bent, squeeze shoulder blades down/back like making a “W”.</p>
      <p><b>Why:</b> builds scapular control and shoulder health without cables.</p>
    `,
    "Prone T Raise": `
      <p>Face down on bench, arms out to sides (T). Lift with shoulder blades, not traps. Pause 1 sec at top.</p>
    `,
    "Prone Y Raise": `
      <p>Face down on bench, arms in a Y shape. Lift slowly, keep shoulders away from ears. Pause at top.</p>
    `,
    "Side-lying External Rotation": `
      <p><b>Setup:</b> lie on your side. Top arm holds a light DB with elbow pinned to your ribs, elbow bent 90°.</p>
      <p><b>Rotate:</b> keep elbow glued to side and rotate forearm upward. Move slowly.</p>
      <p><b>Why:</b> strengthens rotator cuff — key for pain-free pressing/pull-ups.</p>
    `
  };

  function getHow(name){
    return INSTRUCTIONS[name] || `<p class="muted">No instructions found for this item.</p>`;
  }

  // Build workout steps:
  // Each step can contain multiple "blocks":
  // - action blocks: timed practice or set-count blocks with auto rest timers.
  // We'll model "set-count blocks" as repeating loops with quick prompts.
  const WORKOUTS = {
    A: {
      title: "Upper A — Bench + Row + Pull-up Practice",
      steps: [
        stepWarmup(),
        stepPullupPracticeA(),
        stepMainLift("Barbell Bench Press", {sets:4, reps:[5,8], restType:"main"}),
        stepMainLift("Barbell Row (Pause at Top)", {sets:4, reps:[6,10], restType:"main"}),
        stepAccessory("Incline Dumbbell Press", {sets:3, reps:[8,15], restType:"accessory"}),
        stepAccessory("Rear Delt Fly", {sets:3, reps:[15,25], restType:"accessory"}),
        stepAccessoryChoice("Triceps", [
          {name:"Close-Grip Bench Press", sets:3, reps:[6,10], restType:"main"},
          {name:"Skull Crushers (curl bar)", sets:3, reps:[8,12], restType:"accessory"}
        ], "Pick one based on comfort. Elbows cranky? Close-grip bench."),
        stepDone()
      ]
    },
    B: {
      title: "Upper B — Pull-up Strength + OHP + Back",
      steps: [
        stepWarmup(),
        stepPullupStrengthB(),
        stepMainLift("Standing Barbell Overhead Press", {sets:4, reps:[5,8], restType:"main"}),
        stepAccessoryChoice("Row variation", [
          {name:"One-Arm Dumbbell Row", sets:3, reps:[10,15], restType:"accessory", perSide:true},
          {name:"Barbell Row (Pause at Top)", sets:3, reps:[8,12], restType:"main"}
        ], "Choose DB rows if you want strict control; barbell if you want simpler setup."),
        stepAccessoryChoice("Pressing volume", [
          {name:"Dumbbell Bench Press", sets:3, reps:[10,15], restType:"accessory"},
          {name:"Push-ups", sets:3, reps:"near-failure (leave 1–2 reps)", restType:"accessory"}
        ], "Pick DB press for consistent reps; pick push-ups for simplicity."),
        stepAccessory("Curl-bar Curl", {sets:3, reps:[8,12], restType:"accessory"}),
        stepAccessory("Hammer Curl", {sets:2, reps:[10,15], restType:"accessory"}),
        stepAccessory("Lateral Raise", {sets:3, reps:[12,20], restType:"accessory"}),
        stepDone()
      ]
    },
    C: {
      title: "Upper C — Volume + Shoulder Health + Arms",
      steps: [
        stepWarmupLight(),
        stepAccessoryChoice("Bench variation", [
          {name:"Paused Bench Press", sets:3, reps:[5,8], restType:"main"},
          {name:"Close-Grip Bench Press", sets:3, reps:[6,10], restType:"main"}
        ], "Stick with one for 8 weeks to see clean progress."),
        stepMainLift("Barbell Row (Tempo)", {sets:3, reps:[8,12], restType:"main"}),
        stepAccessory("Push-ups", {sets:2, reps:"stop 1–2 reps shy of failure", restType:"accessory"}),
        stepShoulderHealthBlock(),
        stepArmsSuperset(),
        stepHangReinforcement(),
        stepDone()
      ]
    }
  };

  // ---------- Step builders ----------
  function stepWarmup(){
    return {
      type:"guided",
      name:"Warm-up (7–8 min)",
      badge:"Info",
      summary:"Dead hang, scap pull-ups, scap push-ups, prone Y-T-W, then ramp sets.",
      how: `
        <p>This is the same every workout and should take about 7–8 minutes.</p>
        <p><b>Order:</b> (1) Dead hang 2×15–30s • (2) Scap pull-ups 2×6–10 • (3) Scap push-ups 2×8–12 • (4) Prone Y-T-W 1 round (8/8/8) • (5) Ramp sets for the first barbell lift.</p>
        <p><b>Ramp sets:</b> do 2–4 light sets increasing weight gradually (example: empty bar → light → moderate) before your working sets.</p>
      `,
      blocks: [
        timedBlock("Dead Hang", 30, "work", "micro"),
        timedBlock("Rest", null, "rest", "micro"),
        timedBlock("Dead Hang", 30, "work", "micro"),
        timedBlock("Scapular Pull-ups", null, "sets", "micro", {sets:2, reps:"6–10"}),
        timedBlock("Scapular Push-ups", null, "sets", "micro", {sets:2, reps:"8–12"}),
        timedBlock("Prone Y-T-W", null, "sets", "micro", {sets:1, reps:"8 Y / 8 T / 8 W"}),
        {
          kind:"note",
          label:"Ramp sets (no timer)",
          text:"Do 2–4 warm-up sets for your next barbell lift. Keep them easy. Then press Next."
        }
      ]
    };
  }

  function stepWarmupLight(){
    return {
      type:"guided",
      name:"Warm-up (lighter)",
      badge:"Info",
      summary:"Same pattern, slightly faster on volume day.",
      how: `
        <p>Same warm-up idea, just a touch shorter.</p>
        <p><b>Order:</b> Dead hang 1–2×20s • Scap pull-ups 2×6–10 • Scap push-ups 2×8–12 • Prone Y-T-W 1 round.</p>
      `,
      blocks: [
        timedBlock("Dead Hang", 25, "work", "micro"),
        timedBlock("Scapular Pull-ups", null, "sets", "micro", {sets:2, reps:"6–10"}),
        timedBlock("Scapular Push-ups", null, "sets", "micro", {sets:2, reps:"8–12"}),
        timedBlock("Prone Y-T-W", null, "sets", "micro", {sets:1, reps:"8 Y / 8 T / 8 W"}),
        { kind:"note", label:"Ramp sets (optional)", text:"If bench/row feels stiff today, do 1–2 quick ramp sets before your first barbell lift." }
      ]
    };
  }

  function stepPullupPracticeA(){
    return {
      type:"pullupA",
      name:"Pull-up practice (10 min loop)",
      badge:"Info",
      summary:"Top hold → negative → hang. Clean reps only. No grinding.",
      how: `
        <p><b>Goal:</b> accumulate high-quality practice without missing reps.</p>
        <p>You’ll repeat a loop for about 10 minutes:</p>
        <ul>
          <li><b>Top hold</b> 5–10 seconds</li>
          <li><b>Negative</b> 4–6 seconds down</li>
          <li><b>Dead hang</b> 15–25 seconds</li>
        </ul>
        <p><b>Progress weekly:</b> add 1 sec to holds or negatives, or add one extra loop.</p>
      `,
      blocks: [
        loopBlock("Top Hold (Chin Over Bar)", {workSeconds: 8, restSeconds: null, loops: 5, mode:"hold"}),
        loopBlock("Negative Pull-up", {workSeconds: 6, restSeconds: state.settings.restMicro, loops: 5, mode:"neg"}),
        loopBlock("Dead Hang", {workSeconds: 20, restSeconds: state.settings.restMicro, loops: 5, mode:"hang"}),
        { kind:"note", label:"How many loops?", text:"Default is 5 loops. If you feel fresh, do 6. If form degrades, stop at 4." }
      ]
    };
  }

  function stepPullupStrengthB(){
    return {
      type:"pullupB",
      name:"Pull-up strength block",
      badge:"Warn",
      summary:"Perfect singles → negatives → mid-point holds. Never miss reps.",
      how: `
        <p><b>Rule:</b> never miss a rep. Stop before you turn into a shaking noodle.</p>
        <p><b>Sequence:</b></p>
        <ol>
          <li><b>Perfect singles</b>: 6–10 singles (60–90s rest). If you can’t reliably get chin over, do jump-to-top + 1–2s hold + controlled lower.</li>
          <li><b>Negatives</b>: 3 sets × 2 negatives, each 5–8 seconds down.</li>
          <li><b>Mid-point holds</b>: 2 holds × 5–10 seconds at about 90° elbows.</li>
        </ol>
        <p><b>Progress weekly:</b> slower negatives, longer holds, or 1 more perfect single.</p>
      `,
      blocks: [
        setBlock("Perfect Singles (Pull-up)", {sets: 8, reps:"1", restType:"micro", hint:"If the full rep is not clean, do jump-to-top + 2s hold + slow lower."}),
        setBlock("Negative Pull-up", {sets: 3, reps:"2 negatives (5–8 sec each)", restType:"micro"}),
        timedBlock("Mid-point Hold (90° Elbows)", 8, "work", "micro"),
        timedBlock("Rest", null, "rest", "micro"),
        timedBlock("Mid-point Hold (90° Elbows)", 8, "work", "micro"),
      ]
    };
  }

  function stepMainLift(name, cfg){
    return {
      type:"lift",
      name,
      badge:"Main",
      summary: fmtSetsReps(cfg.sets, cfg.reps),
      how: getHow(name),
      blocks: [
        { kind:"note", label:"Ramp sets", text:"Do 2–4 warm-up sets (no timer) before working sets. Then press Next." },
        setBlock(name, cfg)
      ]
    };
  }

  function stepAccessory(name, cfg){
    return {
      type:"acc",
      name,
      badge:"Accessory",
      summary: fmtSetsReps(cfg.sets, cfg.reps),
      how: getHow(name),
      blocks: [
        setBlock(name, cfg)
      ]
    };
  }

  function stepAccessoryChoice(groupName, options, note){
    return {
      type:"choice",
      name: groupName,
      badge:"Choice",
      summary: note,
      how: `<p>${note}</p>`,
      choice: options,
      blocks: [] // will be generated based on selected option
    };
  }

  function stepShoulderHealthBlock(){
    return {
      type:"shoulder",
      name:"Shoulder health block (2 rounds)",
      badge:"Info",
      summary:"Prone T → Prone Y → Side-lying external rotation.",
      how: `
        <p><b>Do 2 rounds</b> with strict control and light weights.</p>
        <ul>
          <li><b>Prone T raises:</b> 12–20</li>
          <li><b>Prone Y raises:</b> 10–15</li>
          <li><b>Side-lying external rotations:</b> 12–20/side</li>
        </ul>
        <p>Use 5 lb (or even no weight) if needed. The goal is control, not load.</p>
      `,
      blocks: [
        setBlock("Prone T Raise", {sets:2, reps:"12–20", restType:"accessory"}),
        setBlock("Prone Y Raise", {sets:2, reps:"10–15", restType:"accessory"}),
        setBlock("Side-lying External Rotation", {sets:2, reps:"12–20/side", restType:"accessory"}),
      ]
    };
  }

  function stepArmsSuperset(){
    return {
      type:"superset",
      name:"Arms superset (3 rounds)",
      badge:"Info",
      summary:"DB curls + overhead triceps extension. Minimal rest.",
      how: `
        <p><b>Do 3 rounds:</b></p>
        <ul>
          <li><b>DB curls:</b> 10–15 reps (choose a weight you can control)</li>
          <li><b>Overhead triceps extension:</b> 10–15 reps (KB/DB)</li>
        </ul>
        <p><b>Rest:</b> 45–75 seconds between rounds. Keep reps smooth.</p>
      `,
      blocks: [
        supersetBlock([
          {name:"DB Curls", reps:"10–15"},
          {name:"Overhead Triceps Extension (KB/DB)", reps:"10–15"}
        ], {rounds:3, restType:"accessory"})
      ]
    };
  }

  function stepHangReinforcement(){
    return {
      type:"micro",
      name:"Hanging reinforcement",
      badge:"Info",
      summary:"Easy hangs + scapular pull-ups to reinforce pull-up mechanics.",
      how: `
        <p>This is easy practice to reinforce the pattern without fatigue.</p>
        <p><b>Do:</b> Dead hang 2×20–40s, then scapular pull-ups 2×6–10.</p>
      `,
      blocks: [
        timedBlock("Dead Hang", 30, "work", "micro"),
        timedBlock("Rest", null, "rest", "micro"),
        timedBlock("Dead Hang", 30, "work", "micro"),
        setBlock("Scapular Pull-ups", {sets:2, reps:"6–10", restType:"micro"})
      ]
    };
  }

  function stepDone(){
    return {
      type:"done",
      name:"Finish",
      badge:"OK",
      summary:"Great work. Save completion to history.",
      how: `
        <p><b>Done.</b> Hydrate, easy shoulder circles, and note your main lift weights if you want progression next time.</p>
        <p>Tip: after cycling days, you can add 2 quick sets of hangs + scap pull-ups to speed up pull-up progress.</p>
      `,
      blocks: [
        { kind:"complete" }
      ]
    };
  }

  // ---------- Blocks ----------
  function timedBlock(label, seconds, phaseKind, restProfile, setsMeta){
    // label: exercise name or "Rest"
    // seconds: number or null (use rest profile)
    // phaseKind: "work" | "rest" | "sets"
    return {
      kind: phaseKind === "sets" ? "sets" : "timer",
      label,
      seconds,
      restProfile,
      setsMeta: setsMeta || null
    };
  }

  function setBlock(name, cfg){
    // sets with auto rest between sets
    return {
      kind:"setRunner",
      label:name,
      cfg
    };
  }

  function loopBlock(name, cfg){
    return {
      kind:"loop",
      label:name,
      cfg
    };
  }

  function supersetBlock(exercises, cfg){
    return {
      kind:"superset",
      label:"Superset",
      exercises,
      cfg
    };
  }

  // ---------- Build "flattened timeline" ----------
  // For usability: we create a sequence of "playerSteps" which are atomic timed/instruction phases:
  // ex: "Bench set 1 (do reps)" -> "Rest" -> "Bench set 2" -> ...
  function buildTimeline(sessionKey){
    const session = WORKOUTS[sessionKey];
    const timeline = [];
    let stepCounter = 0;

    session.steps.forEach((step, stepIdx) => {
      // For choice steps, use stored selection or default first option.
      if(step.type === "choice"){
        const choiceKey = `choice_${sessionKey}_${stepIdx}`;
        const selectedName = state.logs[choiceKey]?.selected || step.choice[0].name;
        const selected = step.choice.find(o => o.name === selectedName) || step.choice[0];

        // insert an instruction tile about the choice (but auto-proceeds)
        timeline.push({
          id: mkStepId(sessionKey, stepCounter++),
          sessionKey, stepIdx,
          title: step.name,
          subtitle: step.summary,
          kind: "choiceInfo",
          choiceKey,
          choiceOptions: step.choice.map(o => o.name),
          selected: selected.name,
          howHTML: `<p><b>Selected:</b> ${escapeHtml(selected.name)}</p><p class="muted tiny">You can change this in the step card below before starting, or later from the run list.</p>` + (getHow(selected.name) || ""),
          phase: "INFO",
          duration: 0
        });

        // add the selected block as a set runner
        const cfg = {sets:selected.sets, reps:selected.reps, restType:selected.restType, perSide: selected.perSide || false};
        timeline.push(...expandSetRunner(sessionKey, stepIdx, selected.name, cfg, stepCounter));
        stepCounter = timeline.length;
        return;
      }

      // Expand blocks
      const blocks = step.blocks || [];
      // Add a step header entry (info-only)
      timeline.push({
        id: mkStepId(sessionKey, stepCounter++),
        sessionKey, stepIdx,
        title: step.name,
        subtitle: step.summary || "",
        kind: "stepHeader",
        howHTML: step.how || getHow(step.name),
        phase:"INFO",
        duration: 0
      });

      blocks.forEach((b) => {
        if(b.kind === "timer"){
          const dur = (b.seconds == null) ? restSecondsForProfile(b.restProfile) : b.seconds;
          // Add prep countdown before timed segments (except if duration==0)
          timeline.push(...prepThenTimer(sessionKey, stepIdx, b.label, dur, "TIMER", stepCounter));
          stepCounter = timeline.length;
        }
        else if(b.kind === "note"){
          timeline.push({
            id: mkStepId(sessionKey, stepCounter++),
            sessionKey, stepIdx,
            title: b.label,
            subtitle: b.text,
            kind: "note",
            howHTML: `<p>${escapeHtml(b.text)}</p>`,
            phase: "INFO",
            duration: 0
          });
        }
        else if(b.kind === "setRunner"){
          timeline.push(...expandSetRunner(sessionKey, stepIdx, b.label, b.cfg, stepCounter));
          stepCounter = timeline.length;
        }
        else if(b.kind === "loop"){
          timeline.push(...expandLoop(sessionKey, stepIdx, b.label, b.cfg, stepCounter));
          stepCounter = timeline.length;
        }
        else if(b.kind === "superset"){
          timeline.push(...expandSuperset(sessionKey, stepIdx, b.exercises, b.cfg, stepCounter));
          stepCounter = timeline.length;
        }
        else if(b.kind === "complete"){
          timeline.push({
            id: mkStepId(sessionKey, stepCounter++),
            sessionKey, stepIdx,
            title: "Complete session",
            subtitle: "Tap Finish to save to history.",
            kind: "complete",
            howHTML: `<p>Nice work. When you’re ready, press <b>Finish Session</b>.</p>`,
            phase: "DONE",
            duration: 0
          });
        }
      });
    });

    return timeline;
  }

  function prepThenTimer(sessionKey, stepIdx, label, seconds, kind, stepCounter){
    const prep = Math.max(3, clampInt(state.settings.prepSeconds, 3, 45));
    const arr = [];
    arr.push({
      id: mkStepId(sessionKey, stepCounter++),
      sessionKey, stepIdx,
      title: "Get ready",
      subtitle: `Next: ${label}`,
      kind: "prep",
      howHTML: `<p><b>Next:</b> ${escapeHtml(label)}</p><p class="muted tiny">Set up your position and breathe. Timer starts automatically.</p>` + getHow(label),
      phase: "PREP",
      duration: prep
    });
    arr.push({
      id: mkStepId(sessionKey, stepCounter++),
      sessionKey, stepIdx,
      title: label,
      subtitle: `Timer: ${seconds}s`,
      kind: kind,
      howHTML: getHow(label),
      phase: "WORK",
      duration: seconds
    });
    return arr;
  }

  function expandSetRunner(sessionKey, stepIdx, label, cfg, stepCounter){
    const sets = cfg.sets || 1;
    const reps = cfg.reps;
    const rest = restSecondsForType(cfg.restType || "accessory");
    const perSide = !!cfg.perSide;
    const arr = [];

    // add an info entry that explains the movement and the scheme
    arr.push({
      id: mkStepId(sessionKey, stepCounter++),
      sessionKey, stepIdx,
      title: label,
      subtitle: `${sets} sets × ${Array.isArray(reps)? `${reps[0]}–${reps[1]}`: reps}${perSide? " (per side)" : ""}`,
      kind: "scheme",
      howHTML: getHow(label),
      phase: "INFO",
      duration: 0
    });

    for(let s=1; s<=sets; s++){
      // "Do the set" prompt — no timer (you control rep speed), but we still give you a prep countdown so you can set up.
      const prep = Math.max(3, clampInt(state.settings.prepSeconds, 3, 45));
      arr.push({
        id: mkStepId(sessionKey, stepCounter++),
        sessionKey, stepIdx,
        title: `Get ready`,
        subtitle: `${label} — set ${s}/${sets}`,
        kind: "prep",
        howHTML: `<p><b>${escapeHtml(label)}</b> — set <b>${s}/${sets}</b></p>
                  <p class="muted tiny">Set up safely; the prompt will auto-advance to the set screen.</p>` + getHow(label),
        phase: "PREP",
        duration: prep
      });

      arr.push({
        id: mkStepId(sessionKey, stepCounter++),
        sessionKey, stepIdx,
        title: `${label} — Set ${s}/${sets}`,
        subtitle: `Do ${Array.isArray(reps)? `${reps[0]}–${reps[1]}`: reps}${perSide? " / side" : ""}. Stop with ~2 reps in reserve.`,
        kind: "set",
        howHTML: getHow(label) + `<p class="muted tiny"><b>Target:</b> ${escapeHtml(Array.isArray(reps)? `${reps[0]}–${reps[1]}`: reps)}${perSide? " per side" : ""}</p>`,
        phase: "INFO",
        duration: 0
      });

      if(s < sets){
        arr.push(...prepThenTimer(sessionKey, stepIdx, "Rest", rest, "REST", stepCounter));
        stepCounter = arr.length;
      }
    }
    return arr;
  }

  function expandLoop(sessionKey, stepIdx, label, cfg, stepCounter){
    const loops = cfg.loops || 4;
    const workSeconds = cfg.workSeconds || 8;
    const restSeconds = (cfg.restSeconds == null) ? restSecondsForType("micro") : cfg.restSeconds;
    const arr = [];

    arr.push({
      id: mkStepId(sessionKey, stepCounter++),
      sessionKey, stepIdx,
      title: label,
      subtitle: `${loops} loops • ${workSeconds}s work`,
      kind: "scheme",
      howHTML: getHow(label),
      phase:"INFO",
      duration: 0
    });

    for(let i=1; i<=loops; i++){
      arr.push(...prepThenTimer(sessionKey, stepIdx, `${label} (loop ${i}/${loops})`, workSeconds, "TIMER", stepCounter));
      stepCounter = arr.length;

      // Rest between loops (except after last if you want)
      if(i < loops && restSeconds > 0){
        arr.push(...prepThenTimer(sessionKey, stepIdx, "Rest", restSeconds, "REST", stepCounter));
        stepCounter = arr.length;
      }
    }
    return arr;
  }

  function expandSuperset(sessionKey, stepIdx, exercises, cfg, stepCounter){
    const rounds = cfg.rounds || 3;
    const rest = restSecondsForType(cfg.restType || "accessory");
    const arr = [];
    arr.push({
      id: mkStepId(sessionKey, stepCounter++),
      sessionKey, stepIdx,
      title: `Superset`,
      subtitle: `${rounds} rounds`,
      kind:"scheme",
      howHTML: `<p><b>Superset:</b> do both movements back-to-back, then rest.</p>` +
               exercises.map(ex => `<p>• <b>${escapeHtml(ex.name)}</b>: ${escapeHtml(ex.reps)}</p>`).join("") +
               `<p class="muted tiny">Rest ${rest}s between rounds.</p>`,
      phase:"INFO",
      duration:0
    });

    for(let r=1; r<=rounds; r++){
      // For each exercise, show an info step (no timer) with prep countdown before each to keep flow safe.
      for(const ex of exercises){
        const prep = Math.max(3, clampInt(state.settings.prepSeconds, 3, 45));
        arr.push({
          id: mkStepId(sessionKey, stepCounter++),
          sessionKey, stepIdx,
          title:"Get ready",
          subtitle:`Round ${r}/${rounds}: ${ex.name}`,
          kind:"prep",
          howHTML:`<p><b>Round ${r}/${rounds}</b> — next: <b>${escapeHtml(ex.name)}</b> (${escapeHtml(ex.reps)})</p>` + (getHow(ex.name) || ""),
          phase:"PREP",
          duration: prep
        });
        arr.push({
          id: mkStepId(sessionKey, stepCounter++),
          sessionKey, stepIdx,
          title:`${ex.name}`,
          subtitle:`Round ${r}/${rounds} • Do ${ex.reps}`,
          kind:"set",
          howHTML:(getHow(ex.name) || `<p>${escapeHtml(ex.name)}: ${escapeHtml(ex.reps)}</p>`),
          phase:"INFO",
          duration:0
        });
      }

      if(r < rounds){
        arr.push(...prepThenTimer(sessionKey, stepIdx, "Rest", rest, "REST", stepCounter));
        stepCounter = arr.length;
      }
    }
    return arr;
  }

  // ---------- Helpers ----------
  function restSecondsForType(type){
    if(type === "main") return clampInt(state.settings.restMain, 30, 300);
    if(type === "micro") return clampInt(state.settings.restMicro, 20, 120);
    return clampInt(state.settings.restAccessory, 20, 180);
  }
  function restSecondsForProfile(profile){
    if(profile === "main") return restSecondsForType("main");
    if(profile === "micro") return restSecondsForType("micro");
    return restSecondsForType("accessory");
  }
  function clampInt(v, a, b){
    v = parseInt(v, 10);
    if(Number.isNaN(v)) v = a;
    return Math.max(a, Math.min(b, v));
  }
  function mmss(secs){
    secs = Math.max(0, Math.floor(secs));
    const m = Math.floor(secs/60);
    const s = secs%60;
    return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
  }
  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, (m)=>({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  // ---------- Player state & runtime ----------
  let timeline = buildTimeline(state.session);
  let sessionStartTs = null;

  function currentNode(){ return timeline[state.player.stepIndex] || null; }
  function nextNode(){ return timeline[state.player.stepIndex+1] || null; }

  function setSession(key){
    state.session = key;
    state.player.running = false;
    state.player.paused = false;
    state.player.stepIndex = 0;
    state.player.phase = "READY";
    state.player.remaining = 0;
    state.player.phaseTotal = 0;
    state.player.lastTick = 0;
    timeline = buildTimeline(key);
    sessionStartTs = null;
    saveSilently();
    initUI();
    toast(`Session ${key} loaded`);
  }

  function saveSilently(){
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }

  // If current node is timed, set timer
  function enterNode(idx){
    state.player.stepIndex = idx;
    const node = currentNode();
    state.player.phase = node?.phase || "READY";
    if(node && node.duration && node.duration > 0){
      state.player.phaseTotal = node.duration;
      state.player.remaining = node.duration;
      state.player.lastTick = performance.now();
    } else {
      state.player.phaseTotal = 0;
      state.player.remaining = 0;
      state.player.lastTick = performance.now();
    }
    saveSilently();
    render();
  }

  function start(){
    if(state.player.running && state.player.paused){
      state.player.paused = false;
      state.player.lastTick = performance.now();
      saveSilently();
      render();
      return;
    }
    if(state.player.running) return;

    state.player.running = true;
    state.player.paused = false;
    sessionStartTs = Date.now();

    // ensure first node
    if(state.player.stepIndex < 0 || state.player.stepIndex >= timeline.length){
      enterNode(0);
    } else {
      // if at READY with zero timeline, rebuild
      timeline = buildTimeline(state.session);
      render();
    }

    // If current node has 0 duration, we still want auto-advance only when user presses Skip/Next.
    // But for timed nodes, it auto-advances.
    saveSilently();
    toast("Started");
    render();
  }

  function pause(){
    if(!state.player.running) return;
    state.player.paused = true;
    saveSilently();
    toast("Paused");
    render();
  }

  function toggleStartPause(){
    // ensure audio context allowed
    if(audioCtx && audioCtx.state === "suspended") audioCtx.resume().catch(()=>{});
    if(!state.player.running) start();
    else if(state.player.paused) start(); // resume
    else pause();
  }

  function back(){
    const idx = Math.max(0, state.player.stepIndex - 1);
    enterNode(idx);
    toast("Back");
  }

  function skip(){
    // Skip current timer or jump to next node
    const node = currentNode();
    if(node && node.duration > 0){
      state.player.remaining = 1; // force finish on next tick
      state.player.lastTick = performance.now() - 1000;
      render();
      return;
    }
    advance();
  }

  function advance(){
    const idx = state.player.stepIndex + 1;
    if(idx >= timeline.length){
      finishSession();
      return;
    }
    enterNode(idx);
    const node = currentNode();
    if(node && node.duration > 0){
      beep();
    }
  }

  function finishSession(){
    // Record session completion (best effort)
    const completedSteps = state.player.stepIndex + 1;
    const durationSeconds = sessionStartTs ? Math.floor((Date.now() - sessionStartTs)/1000) : null;

    state.history.unshift({
      ts: Date.now(),
      session: state.session,
      durationSeconds: durationSeconds ?? 0,
      completedSteps
    });
    state.history = state.history.slice(0, 30);

    state.player.running = false;
    state.player.paused = false;
    state.player.phase = "DONE";
    saveState();
    toast("Session saved to history");
    render();
  }

  function tick(){
    if(!state.player.running || state.player.paused) return;

    const node = currentNode();
    if(!node) return;

    // If current node is timed
    if(node.duration && node.duration > 0){
      const now = performance.now();
      const dt = (now - state.player.lastTick) / 1000;
      state.player.lastTick = now;
      state.player.remaining -= dt;

      // Countdown beeps at 3..2..1 for prep and rest and timers
      const r = Math.ceil(state.player.remaining);
      if(r === 3 || r === 2 || r === 1){
        // Avoid spamming: only beep when crossing boundary
        // We'll check close to integer boundaries
        if(Math.abs(state.player.remaining - r) < 0.06){
          beep();
        }
      }

      if(state.player.remaining <= 0){
        beep();
        saveSilently();
        advance();
        return;
      }
      saveSilently();
    }
  }

  setInterval(tick, 200);

  // ---------- Run list & UI ----------
  const el = (id)=>document.getElementById(id);
  const statusPill = el("statusPill");
  const stepCount = el("stepCount");
  const nextLabel = el("nextLabel");
  const sessionLabel = el("sessionLabel");
  const timeDisplay = el("timeDisplay");
  const phaseDisplay = el("phaseDisplay");
  const progressBar = el("progressBar");
  const exerciseTitle = el("exerciseTitle");
  const exerciseSub = el("exerciseSub");
  const howText = el("howText");
  const runList = el("runList");
  const playerMeta = el("playerMeta");

  const btnStartPause = el("btnStartPause");
  const btnBack = el("btnBack");
  const btnSkip = el("btnSkip");

  const tabA = el("tabA");
  const tabB = el("tabB");
  const tabC = el("tabC");

  const prepSeconds = el("prepSeconds");
  const restMain = el("restMain");
  const restAccessory = el("restAccessory");
  const restMicro = el("restMicro");
  const soundMode = el("soundMode");

  const btnResetAll = el("btnResetAll");

  const logWeight = el("logWeight");
  const logNotes = el("logNotes");
  const btnSaveLog = el("btnSaveLog");

  const kpiLast = el("kpiLast");
  const kpiCount = el("kpiCount");
  const historyBox = el("historyBox");

  function toast(msg){
    const t = el("toast");
    t.textContent = msg;
    t.classList.add("on");
    clearTimeout(toast._to);
    toast._to = setTimeout(()=>t.classList.remove("on"), 900);
  }

  function refreshKPIs(){
    const h = state.history || [];
    kpiCount.textContent = String(h.length);
    if(h.length){
      const last = h[0];
      const d = new Date(last.ts);
      const dur = last.durationSeconds ? `${Math.floor(last.durationSeconds/60)}m ${last.durationSeconds%60}s` : "—";
      kpiLast.textContent = `${last.session} • ${d.toLocaleDateString()} • ${dur}`;
    } else {
      kpiLast.textContent = "—";
    }

    // History box
    if(!h.length){
      historyBox.innerHTML = `<p class="muted">No history yet. Finish a session and it’ll appear here.</p>`;
      return;
    }
    const rows = h.slice(0, 10).map(x=>{
      const d = new Date(x.ts);
      const dur = x.durationSeconds ? `${Math.floor(x.durationSeconds/60)}m ${x.durationSeconds%60}s` : "—";
      return `<div class="item">
        <div class="left">
          <p class="name">Session ${escapeHtml(x.session)} • ${escapeHtml(d.toLocaleDateString())}</p>
          <p class="desc">Duration: ${escapeHtml(dur)} • Steps completed: ${escapeHtml(String(x.completedSteps))}</p>
        </div>
        <span class="badge info">${escapeHtml(new Date(x.ts).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"}))}</span>
      </div>`;
    }).join("");
    historyBox.innerHTML = rows;
  }

  function renderTabs(){
    tabA.classList.toggle("on", state.session==="A");
    tabB.classList.toggle("on", state.session==="B");
    tabC.classList.toggle("on", state.session==="C");
    tabA.setAttribute("aria-selected", state.session==="A");
    tabB.setAttribute("aria-selected", state.session==="B");
    tabC.setAttribute("aria-selected", state.session==="C");
  }

  function render(){
    // Rebuild timeline if settings changed (rest durations)
    // We'll keep it simple: rebuild only when not running, or when current node label "Rest" depends on settings.
    // But for clarity, always rebuild runList; keep current index stable if possible.
    const idx = state.player.stepIndex;
    const oldId = timeline[idx]?.id;
    timeline = buildTimeline(state.session);

    // Attempt to restore current index by matching id
    if(oldId){
      const newIdx = timeline.findIndex(n => n.id === oldId);
      if(newIdx >= 0) state.player.stepIndex = newIdx;
    }

    renderTabs();
    sessionLabel.textContent = state.session;

    const node = currentNode();
    const next = nextNode();

    stepCount.textContent = `${Math.min(state.player.stepIndex+1, timeline.length)}/${timeline.length}`;
    nextLabel.textContent = next ? (next.title || "—") : "—";

    // Status pill
    let status = "Ready";
    if(state.player.running && state.player.paused) status = "Paused";
    else if(state.player.running) status = "Running";
    else if(state.player.phase === "DONE") status = "Done";
    statusPill.textContent = status;

    // Player meta
    const sessionTitle = WORKOUTS[state.session].title;
    playerMeta.textContent = sessionTitle;

    // Timer display
    if(node && node.duration > 0){
      timeDisplay.textContent = mmss(state.player.remaining);
      phaseDisplay.textContent = node.phase === "PREP" ? "Get ready" :
                                node.phase === "WORK" ? "Timer running" :
                                node.phase === "DONE" ? "Complete" : "Timer";
      const pct = state.player.phaseTotal ? (1 - (state.player.remaining / state.player.phaseTotal)) * 100 : 0;
      progressBar.style.width = `${Math.max(0, Math.min(100, pct))}%`;
    } else {
      timeDisplay.textContent = "00:00";
      phaseDisplay.textContent = node ? "Do the step" : "Ready";
      progressBar.style.width = `0%`;
    }

    // Exercise title + sub
    if(!node){
      exerciseTitle.textContent = "Select a session";
      exerciseSub.textContent = "Pick A/B/C and press Start.";
      howText.innerHTML = `<p class="muted">No active step.</p>`;
    } else {
      exerciseTitle.textContent = node.title || "Step";
      exerciseSub.textContent = node.subtitle || "";
      howText.innerHTML = node.howHTML || `<p class="muted">No instructions.</p>`;
    }

    // Start/Pause button label
    if(!state.player.running) btnStartPause.textContent = "Start";
    else if(state.player.paused) btnStartPause.textContent = "Resume";
    else btnStartPause.textContent = "Pause";

    // Run list
    renderRunList();

    // KPIs
    refreshKPIs();
  }

  function renderRunList(){
    // Show a compact list of top-level plan steps, and highlight current timeline node.
    const currentIdx = state.player.stepIndex;
    const nodes = timeline;

    // Make list items for timeline nodes but keep it scannable: show only headers, schemes, timers, rests, and sets
    // We'll display a rolling window around current position for phone usability:
    const start = Math.max(0, currentIdx - 6);
    const end = Math.min(nodes.length, currentIdx + 10);

    const windowNodes = nodes.slice(start, end);

    runList.innerHTML = windowNodes.map((n, i)=>{
      const idx = start + i;
      const active = idx === currentIdx;
      const badge = badgeForNode(n);
      const desc = n.subtitle || "";
      return `
        <div class="item" style="${active ? "outline: 2px solid rgba(110,231,255,.45);" : ""}">
          <div class="left">
            <p class="name">${escapeHtml(n.title)}</p>
            <p class="desc">${escapeHtml(desc)}</p>
          </div>
          <div style="display:flex; flex-direction:column; gap:8px; align-items:flex-end">
            <span class="badge ${badge.cls}">${escapeHtml(badge.txt)}</span>
            ${n.kind==="choiceInfo" ? renderChoiceMini(n) : ""}
            <button class="btn small ghost" onclick="window.__ubJump(${idx})">Go</button>
          </div>
        </div>
      `;
    }).join("");

    // expose jump
    window.__ubJump = (idx) => {
      enterNode(idx);
      toast("Jumped");
    };

    // expose choice change
    window.__ubChoose = (choiceKey, name) => {
      state.logs[choiceKey] = {...(state.logs[choiceKey]||{}), selected:name, ts: Date.now()};
      saveSilently();
      toast(`Selected: ${name}`);
      render();
    };
  }

  function renderChoiceMini(node){
    const opts = node.choiceOptions || [];
    if(!opts.length) return "";
    return `
      <div style="display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end; max-width: 220px">
        ${opts.map(o=>{
          const on = o === node.selected;
          return `<button class="btn small ${on ? "primary":"ghost"}" onclick="window.__ubChoose('${escapeHtml(node.choiceKey)}','${escapeHtml(o)}')" style="height:36px; padding:0 10px">${escapeHtml(shorten(o, 18))}</button>`;
        }).join("")}
      </div>
    `;
  }

  function shorten(s, n){
    s = String(s);
    if(s.length <= n) return s;
    return s.slice(0, n-1) + "…";
  }

  function badgeForNode(n){
    if(n.kind === "prep") return {txt:"PREP", cls:"warn"};
    if(n.kind === "REST") return {txt:"REST", cls:"warn"};
    if(n.title === "Rest") return {txt:"REST", cls:"warn"};
    if(n.kind === "TIMER") return {txt:"TIMER", cls:"info"};
    if(n.kind === "set") return {txt:"SET", cls:"info"};
    if(n.kind === "scheme") return {txt:"PLAN", cls:"info"};
    if(n.kind === "complete") return {txt:"DONE", cls:"ok"};
    if(n.kind === "stepHeader") return {txt:"STEP", cls:"info"};
    if(n.kind === "note") return {txt:"NOTE", cls:"info"};
    if(n.kind === "choiceInfo") return {txt:"CHOOSE", cls:"info"};
    return {txt:"—", cls:"info"};
  }

  // ---------- Settings wiring ----------
  function initSettingsUI(){
    prepSeconds.value = state.settings.prepSeconds;
    restMain.value = state.settings.restMain;
    restAccessory.value = state.settings.restAccessory;
    restMicro.value = state.settings.restMicro;
    soundMode.value = state.settings.soundMode;

    prepSeconds.onchange = () => { state.settings.prepSeconds = clampInt(prepSeconds.value,3,45); saveState(); render(); };
    restMain.onchange = () => { state.settings.restMain = clampInt(restMain.value,30,300); saveState(); render(); };
    restAccessory.onchange = () => { state.settings.restAccessory = clampInt(restAccessory.value,20,180); saveState(); render(); };
    restMicro.onchange = () => { state.settings.restMicro = clampInt(restMicro.value,20,120); saveState(); render(); };
    soundMode.onchange = () => { state.settings.soundMode = soundMode.value; saveState(); };
  }

  // ---------- Logging ----------
  function saveLogForCurrent(){
    const node = currentNode();
    if(!node) return;
    const key = `log_${node.id}`;
    state.logs[key] = {
      weight: logWeight.value.trim(),
      notes: logNotes.value.trim(),
      ts: Date.now()
    };
    saveState();
  }

  function loadLogForCurrent(){
    const node = currentNode();
    if(!node) return;
    const key = `log_${node.id}`;
    const l = state.logs[key];
    logWeight.value = l?.weight || "";
    logNotes.value = l?.notes || "";
  }

  // Update logs box when node changes
  const _render = render;
  render = function(){
    _render();
    loadLogForCurrent();
  };

  // ---------- Init ----------
  function initUI(){
    renderTabs();
    initSettingsUI();

    // Attach events
    btnStartPause.onclick = () => {
      // kick audio (some browsers)
      if(!audioCtx) {
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch(e){}
      }
      toggleStartPause();
    };
    btnBack.onclick = back;
    btnSkip.onclick = () => {
      const node = currentNode();
      if(node?.kind === "complete"){
        // finish
        finishSession();
        return;
      }
      skip();
      toast("Next");
    };

    tabA.onclick = () => setSession("A");
    tabB.onclick = () => setSession("B");
    tabC.onclick = () => setSession("C");

    btnResetAll.onclick = () => {
      // no confirm dialog per your requirement; just do it
      resetAll();
    };

    btnSaveLog.onclick = saveLogForCurrent;

    // Build timeline and render
    timeline = buildTimeline(state.session);

    // Make sure index valid
    if(state.player.stepIndex >= timeline.length) state.player.stepIndex = 0;

    // If previously running, keep it paused on reload (safer on mobile refresh)
    if(state.player.running){
      state.player.paused = true;
      state.player.running = true;
      toast("Restored (paused)");
    }
    saveSilently();
    render();
  }

  initUI();

  // Expose for debugging
  window.__ub = {
    getState: ()=>state,
    setSession,
    start, pause, skip, back,
    buildTimeline: ()=>buildTimeline(state.session)
  };

  // Small helper: make "Rest" instructions consistent
  INSTRUCTIONS["Rest"] = `
    <p><b>Rest time.</b> Walk around, breathe, sip water.</p>
    <p><b>After main lifts:</b> keep rest longer so your next set stays strong.</p>
    <p><b>After accessories:</b> shorter rest is fine.</p>
  `;

})();
</script>
</body>
</html>
